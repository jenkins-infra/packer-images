//!/usr/bin/env groovy
//default node for pipeline and stages except for the amd/intel builds
String mainNodeLabel="linux-arm64-docker"
String gitCommit = ''
Boolean needPackerBuild = true

if (env.BRANCH_IS_PRIMARY) {
    properties([
        buildDiscarder(logRotator(numToKeepStr: '10')),
        // Daily build is enough: only the tagged build would generate downstream PRs on jenkins-infra
        pipelineTriggers([cron('@daily')]),
        // Do not build concurently on the principal branch (to avoid Azure ARM issues with shared resources)
        disableConcurrentBuilds(),
    ])
}

if (env.CHANGE_ID) {
  properties([
    // Do not build concurently on pull requests (to avoid Azure ARM issues with shared resources), and abort previous running build
    disableConcurrentBuilds(abortPrevious: true)
  ])
}

// The node to be used depends on the build type: this function executes the pipeline code block provided as "body"
// into the correct node type based on the provided arguments
def withPackerNode(String nodeLabel, Closure body) {
  if (nodeLabel != '') {
    echo "Launch node : $nodeLabel"
    node(nodeLabel) {
      echo "Within node : $nodeLabel"
      checkout scm
      sh 'env'
      // Cleanup any remnant of packer plugins on this agent
      sh 'rm -rf /home/jenkins/.config /home/jenkins/.packer*'
      // Initialize the packer project by installing the plugins in $PACKER_HOME_DIR/ - ref. https://www.packer.io/docs/configure
      // This function must be called for each distinct agent but only one time (as plugins are OS and CPU specifics)
      sh 'packer init ./'
      return body.call()
    }
  } else {
    // No node allocation: keep the same default agent node (e.g. declarative top-level)
    echo "Using Main node"
    // packer build only once for the main node
    if (needPackerBuild) {
      needPackerBuild = false
      // Cleanup any remnant of packer plugins on this agent
      sh 'rm -rf /home/jenkins/.config /home/jenkins/.packer*'
      // Initialize the packer project by installing the plugins in $PACKER_HOME_DIR/ - ref. https://www.packer.io/docs/configure
      // This function must be called for each distinct agent but only one time (as plugins are OS and CPU specifics)
      sh 'packer init ./'
    }
    return body.call()
  }
}

// Average build time is ~50 min but windows can takes 45min of updates on AWS
timeout(time: 120, unit: 'MINUTES') {

  // main script block
  node(mainNodeLabel) {

    stage('Checkout and Packer init') {
      // To set pkr_var_scm_ref globally
      scmvars = checkout scm
      gitCommit = scmvars.GIT_COMMIT
    }

    // To allow using ASDF shims
    env.PATH = "${env.PATH}:/home/jenkins/.asdf/shims:/home/jenkins/.asdf/bin"
    env.DRYRUN = "${env.BRANCH_IS_PRIMARY ? 'false' : 'true'}"

    // Define parrallels stages
    def sidestages = [failFast:false]
    sidestages["updatecli"] = {
      // TODO: Implement https://github.com/jenkins-infra/pipeline-library/issues/518 to allow using the updatecli() library function
      withCredentials([
        usernamePassword(
          credentialsId: 'github-app-updatecli-on-jenkins-infra',
          usernameVariable: 'USERNAME_VALUE', // Setting this variable is mandatory, even if of not used when the credentials is a githubApp one
          passwordVariable: 'UPDATECLI_GITHUB_TOKEN'
        )
      ]) {
        sh 'updatecli version'
        sh 'updatecli diff --values ./updatecli/values.yaml --config ./updatecli/updatecli.d'
        if (env.BRANCH_IS_PRIMARY) {
          sh 'updatecli apply --values ./updatecli/values.yaml --config ./updatecli/updatecli.d'
        }
      }
    }

    sidestages["GC on AWS us-east-2"] = {
      env.AWS_DEFAULT_REGION    = 'us-east-2'
      withCredentials([
        string(
            credentialsId: 'packer-aws-access-key-id',
            variable: 'AWS_ACCESS_KEY_ID'
        ),
        string(
            credentialsId: 'packer-aws-secret-access-key',
            variable: 'AWS_SECRET_ACCESS_KEY'
        )
      ]) {
        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
          sh './cleanup/aws.sh'
          sh './cleanup/aws_images.sh 1 dev'
          sh './cleanup/aws_images.sh 7 staging'
          sh './cleanup/aws_images.sh 60 prod'
          sh './cleanup/aws_snapshots.sh'
        }
      }
    }

    sidestages["GC on Azure"] = {
      withCredentials([
        azureServicePrincipal(
          credentialsId: 'packer-azure-serviceprincipal',
          subscriptionIdVariable: 'PACKER_AZURE_SUBSCRIPTION_ID',
          clientIdVariable: 'PACKER_AZURE_CLIENT_ID',
          clientSecretVariable: 'PACKER_AZURE_CLIENT_SECRET',
          tenantIdVariable: 'PACKER_AZURE_TENANT_ID'
        )
      ]) {
        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
          sh 'az login --service-principal -u "$PACKER_AZURE_CLIENT_ID" -p "$PACKER_AZURE_CLIENT_SECRET" -t "$PACKER_AZURE_TENANT_ID"'
          sh 'az account set -s "$PACKER_AZURE_SUBSCRIPTION_ID"'
          sh './cleanup/azure_gallery_images.sh 1 dev'
          sh './cleanup/azure_gallery_images.sh 7 staging'
          sh './cleanup/azure.sh 1 dev'
          sh './cleanup/azure.sh 1 staging'
          sh './cleanup/azure.sh 1 prod'
        }
      }
    }

    def buildstages = [:]
    // packer builds
    def listbuilds = [
      [cpu_architecture:'amd64', agent_type:'ubuntu-22.04', compute_type:'azure-arm',   nodeLabel:'linux-amd64-docker'],
      [cpu_architecture:'amd64', agent_type:'ubuntu-22.04', compute_type:'docker',      nodeLabel:'linux-amd64-docker'],
      [cpu_architecture:'amd64', agent_type:'windows-2019', compute_type:'azure-arm',   nodeLabel:''],
      [cpu_architecture:'amd64', agent_type:'windows-2022', compute_type:'azure-arm',   nodeLabel:''],
      [cpu_architecture:'arm64', agent_type:'ubuntu-22.04', compute_type:'amazon-ebs',  nodeLabel:''],
      [cpu_architecture:'arm64', agent_type:'ubuntu-22.04', compute_type:'azure-arm',   nodeLabel:''],
      [cpu_architecture:'arm64', agent_type:'ubuntu-22.04', compute_type:'docker',      nodeLabel:'']
    ]
    for(int i = 0; i < listbuilds.size(); i++) {
      String stagetitle="Build ${listbuilds[i].cpu_architecture} ${listbuilds[i].agent_type} ${listbuilds[i].compute_type} image on ${listbuilds[i].nodeLabel}"

      // Groovy quirk: create a local copy of these variables in the current loop context, as it matters for the closure scope below
      // Otherwise the environment variables will be mixed between all the parallel stages, creating weird combinations
      // - https://stackoverflow.com/questions/22145763/iterate-and-print-content-of-groovy-closures
      // - http://archive.comsystoreply.de/blog-post/parallel-builds-with-jenkins-pipeline
      String pkr_var_build_type = env.TAG_NAME ? 'prod' : (env.BRANCH_IS_PRIMARY ? 'staging' : 'dev')
      String pkr_var_image_version = env.TAG_NAME ?: ((env.BRANCH_IS_PRIMARY ? 1 : 0) + '.' + (env.CHANGE_ID ?: 0) + '.' + env.BUILD_ID)
      String pkr_var_agent = listbuilds[i].agent_type
      String pkr_var_agent_os_type = listbuilds[i].agent_type.split('-')[0]
      String pkr_var_agent_os_version = listbuilds[i].agent_type.split('-')[1]
      String pkr_var_architecture = listbuilds[i].cpu_architecture
      String pkr_var_image_type = listbuilds[i].compute_type
      String pkr_var_tag_name = env.TAG_NAME
      String nodeLabel = listbuilds[i].nodeLabel

      buildstages[stagetitle] = {
        withPackerNode(nodeLabel) {
          withEnv([
            "PKR_VAR_build_type=$pkr_var_build_type",
            "PKR_VAR_image_version=$pkr_var_image_version",
            "PKR_VAR_agent_os_type=$pkr_var_agent_os_type",
            "PKR_VAR_agent_os_version=$pkr_var_agent_os_version",
            "PKR_VAR_architecture=$pkr_var_architecture",
            "PKR_VAR_image_type=$pkr_var_image_type",
            "PKR_VAR_tag_name=$pkr_var_tag_name",
            "AWS_DEFAULT_REGION='us-east-2'",
            "AGENT_TYPE=$pkr_var_agent",
            "PATH=${WORKSPACE}/.bin:${env.PATH}" // Required if packer needs to be installed
          ]){
            withCredentials([
              string(
                  credentialsId: 'packer-aws-access-key-id',
                  variable: 'AWS_ACCESS_KEY_ID'
              ),
              string(
                  credentialsId: 'packer-aws-secret-access-key',
                  variable: 'AWS_SECRET_ACCESS_KEY'
              ),
              azureServicePrincipal(
                credentialsId: 'packer-azure-serviceprincipal',
                subscriptionIdVariable: 'AZURE_SUBSCRIPTION_ID',
                clientIdVariable: 'AZURE_CLIENT_ID',
                clientSecretVariable: 'AZURE_CLIENT_SECRET',
                tenantIdVariable: 'AZURE_TENANT_ID'
              ),
              usernamePassword(
                credentialsId: 'github-app-infra',
                usernameVariable: 'UNUSED',
                passwordVariable: 'PACKER_GITHUB_API_TOKEN'
              )
            ]) {
              echo "build for: ${PKR_VAR_image_type}.${PKR_VAR_agent_os_type} ${PKR_VAR_agent_os_type}-${PKR_VAR_agent_os_version}:latest jenkinsciinfra/jenkins-agent-${PKR_VAR_agent_os_type}-${PKR_VAR_agent_os_version}:${PKR_VAR_architecture}"

              // packer validate
              sh 'PACKER_LOG=1 packer validate ./'
              // Execute build only for this matrix cell's setup
              retry(count: 2, conditions: [kubernetesAgent(handleNonKubernetes: true), nonresumable()]) {
                sh 'echo PKR_VAR_image_type.PKR_VAR_agent_os_type equal "${PKR_VAR_image_type}.${PKR_VAR_agent_os_type}"'
                sh 'PACKER_LOG=1 packer build -timestamp-ui -force -only="${PKR_VAR_image_type}.${PKR_VAR_agent_os_type}" ./'
                // adding manually a cpu architecture tag to the docker image
                if (PKR_VAR_image_type == 'docker') {
                  sh 'docker tag "jenkinsciinfra/jenkins-agent-${PKR_VAR_agent_os_type}-${PKR_VAR_agent_os_version}:latest" "jenkinsciinfra/jenkins-agent-${PKR_VAR_agent_os_type}-${PKR_VAR_agent_os_version}:${PKR_VAR_architecture}"'
                }
              }
              // if docker and building a tag, push to dockerhub from inside the node
              // else we would loose the docker image
              if (PKR_VAR_image_type == 'docker' && PKR_VAR_tag_name != null) {
                stage('Publish all tags for Docker image') {
                  echo 'Pushing "${AGENT_TYPE}" as jenkinsciinfra/jenkins-agent-"${PKR_VAR_agent_os_type}:${PKR_VAR_tag_name}" & jenkinsciinfra/jenkins-agent-"${PKR_VAR_agent_os_type}":latest for "${PKR_VAR_architecture}"'
                  infra.withDockerPushCredentials {
                    sh 'docker push --all-tags jenkinsciinfra/jenkins-agent-"${AGENT_TYPE}"'
                  }
                }
              }
            }
          }
        }
      }
    }

    //run in parallel
    parallel(sidestages + buildstages)

    // after parallel
    stage('Build Docker Manifest') {
      if (env.TAG_NAME != null){
        // Static variable definition as this stage is outside the matrix scope
        // Improvement: pass dynamically the list of images from the matrix (e.g. use full scripted pipeline) to support other Docker agent types (such as windows-2019 or windows-2022)
        withEnv([
            "agent_type='ubuntu-22.04'"
        ]){
          infra.withDockerPushCredentials {
            sh 'docker manifest create \
                jenkinsciinfra/jenkins-agent-${agent_type}:latest \
                --amend jenkinsciinfra/jenkins-agent-${agent_type}:arm64 \
                --amend jenkinsciinfra/jenkins-agent-${agent_type}:amd64'
            sh 'docker manifest push jenkinsciinfra/jenkins-agent-"${agent_type}":latest'

            sh 'docker manifest create \
                jenkinsciinfra/jenkins-agent-${agent_type}:${TAG_NAME} \
                --amend jenkinsciinfra/jenkins-agent-${agent_type}:arm64 \
                --amend jenkinsciinfra/jenkins-agent-${agent_type}:amd64'
            sh 'docker manifest push jenkinsciinfra/jenkins-agent-"${agent_type}":"${TAG_NAME}"'
          }
        }
      }
    }
  }
}
